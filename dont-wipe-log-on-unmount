Do not trim journal. Always recover the tail.

From: Abutalib Aghayev <agayev@gmail.com>

With this commit, after the first write to the journal, journal always
starts at block 1 and transaction 2.  During mount, we recover and
replay all the entries in the journal and we find out the actual tail.
Newer transactions are written at this new tail.  This is done in
preparation for stopping metadata block writeback.

The change to commit.c prevents the journal superblock from being
updated.  The change to super.c prevents wiping of the journal upon
mount after a clean unmount.  The change to jbd2_mark_journal_empty
always sets the journal start from the beginning and the rest of the
changes to journal.c and recovery.c is for finding the actual tail after
mount (since now we are doing "recovery" on every mount) and updating
in-memory journal superblock, so that new updates are written at the
actual tail of the journal.
---
 fs/ext4/super.c    |  4 ++--
 fs/jbd2/commit.c   |  4 ++--
 fs/jbd2/journal.c  | 11 ++++++-----
 fs/jbd2/recovery.c | 10 +++++++---
 4 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index dde14a7ac6d7..ff77c84ef089 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4539,8 +4539,8 @@ static int ext4_load_journal(struct super_block *sb,
 	if (!(journal->j_flags & JBD2_BARRIER))
 		ext4_msg(sb, KERN_INFO, "barriers disabled");
 
-	if (!ext4_has_feature_journal_needs_recovery(sb))
-		err = jbd2_journal_wipe(journal, !really_read_only);
+	/* if (!ext4_has_feature_journal_needs_recovery(sb)) */
+	/* 	err = jbd2_journal_wipe(journal, !really_read_only); */
 	if (!err) {
 		char *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);
 		if (save)
diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index cf091b79ac99..6cfa74b32ad5 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -898,8 +898,8 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 	 * erase checkpointed transactions from the log by updating journal
 	 * superblock.
 	 */
-	if (update_tail)
-		jbd2_update_log_tail(journal, first_tid, first_block);
+	/* if (update_tail) */
+	/* 	jbd2_update_log_tail(journal, first_tid, first_block); */
 
 	/* End of a transaction!  Finally, we can do checkpoint
            processing: any buffers committed as a result of this
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 3d44dd35c9f0..23e8b2aaf9c3 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -1294,9 +1294,6 @@ static int journal_reset(journal_t *journal)
 
 	journal->j_first = first;
 	journal->j_last = last;
-
-	journal->j_head = first;
-	journal->j_tail = first;
 	journal->j_free = last - first;
 
 	journal->j_tail_sequence = journal->j_transaction_sequence;
@@ -1312,12 +1309,15 @@ static int journal_reset(journal_t *journal)
 	 * attempting a write to a potential-readonly device.
 	 */
 	if (sb->s_start == 0) {
+		journal->j_head = first;
+		journal->j_tail = first;
 		jbd_debug(1, "JBD2: Skipping superblock update on recovered sb "
 			"(start %ld, seq %d, errno %d)\n",
 			journal->j_tail, journal->j_tail_sequence,
 			journal->j_errno);
 		journal->j_flags |= JBD2_FLUSHED;
 	} else {
+		#if 0
 		/* Lock here to make assertions happy... */
 		mutex_lock(&journal->j_checkpoint_mutex);
 		/*
@@ -1331,6 +1331,7 @@ static int journal_reset(journal_t *journal)
 						journal->j_tail,
 						REQ_FUA);
 		mutex_unlock(&journal->j_checkpoint_mutex);
+		#endif
 	}
 	return jbd2_journal_start_thread(journal);
 }
@@ -1439,8 +1440,8 @@ static void jbd2_mark_journal_empty(journal_t *journal, int write_op)
 	jbd_debug(1, "JBD2: Marking journal as empty (seq %d)\n",
 		  journal->j_tail_sequence);
 
-	sb->s_sequence = cpu_to_be32(journal->j_tail_sequence);
-	sb->s_start    = cpu_to_be32(0);
+	sb->s_sequence = cpu_to_be32(2);
+	sb->s_start    = cpu_to_be32(1);
 	read_unlock(&journal->j_state_lock);
 
 	jbd2_write_superblock(journal, write_op);
diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c
index da100044566c..d5c308ec541d 100644
--- a/fs/jbd2/recovery.c
+++ b/fs/jbd2/recovery.c
@@ -32,6 +32,7 @@ struct recovery_info
 {
 	tid_t		start_transaction;
 	tid_t		end_transaction;
+	int		tail_block;
 
 	int		nr_replays;
 	int		nr_revokes;
@@ -282,6 +283,8 @@ int jbd2_journal_recover(journal_t *journal)
 	/* Restart the log at the next transaction ID, thus invalidating
 	 * any existing commit records in the log. */
 	journal->j_transaction_sequence = info.end_transaction;
+	journal->j_tail = info.tail_block;
+	journal->j_head = info.tail_block;
 
 	jbd2_journal_clear_revoke(journal);
 	err2 = sync_blockdev(journal->j_fs_dev);
@@ -484,9 +487,6 @@ static int do_one_pass(journal_t *journal,
 		if (err)
 			goto failed;
 
-		next_log_block++;
-		wrap(journal, next_log_block);
-
 		/* What kind of buffer is it?
 		 *
 		 * If it is a descriptor block, check that it has the
@@ -514,6 +514,9 @@ static int do_one_pass(journal_t *journal,
 		 * all of the sequence number checks.  What are we going
 		 * to do with it?  That depends on the pass... */
 
+		next_log_block++;
+		wrap(journal, next_log_block);
+
 		switch(blocktype) {
 		case JBD2_DESCRIPTOR_BLOCK:
 			/* Verify checksum first */
@@ -791,6 +794,7 @@ static int do_one_pass(journal_t *journal,
 	if (pass == PASS_SCAN) {
 		if (!info->end_transaction)
 			info->end_transaction = next_commit_ID;
+		info->tail_block = next_log_block;
 	} else {
 		/* It's really bad news if different passes end up at
 		 * different places (but possible due to IO errors). */
