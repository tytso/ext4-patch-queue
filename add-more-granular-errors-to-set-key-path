ext4 crypto: adds more granular error messages to the set key path

From: Michael Halcrow <mhalcrow@google.com>

Signed-off-by: Michael Halcrow <mhalcrow@google.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 fs/ext4/crypto.c | 77 ++++++++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 67 insertions(+), 10 deletions(-)

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index 904974c..e892d68 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -606,11 +606,18 @@ static int ext4_get_wrapping_key_from_keyring(
 	payload = (struct encrypted_key_payload *)create_key->payload.data;
 	if (WARN_ON_ONCE(create_key->datalen !=
 			 sizeof(struct ecryptfs_auth_tok))) {
+		printk(KERN_ERR
+		       "%s: Got auth tok length [%d], expected [%ld]\n",
+		       __func__, create_key->datalen,
+		       sizeof(struct ecryptfs_auth_tok));
 		return -EINVAL;
 	}
 	auth_tok = (struct ecryptfs_auth_tok *)(&(payload)->payload_data);
 	if (WARN_ON_ONCE(!(auth_tok->token.password.flags &
 			   ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET))) {
+		printk(KERN_ERR
+		       "%s: ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET not set in auth_tok->token.password.flags\n",
+		       __func__);
 		return -EINVAL;
 	}
 	BUILD_BUG_ON(EXT4_MAX_KEY_SIZE < EXT4_AES_256_XTS_KEY_SIZE);
@@ -742,8 +749,11 @@ static int ext4_hmac(bool derivation, const char *key, size_t key_size,
 	int res = 0;
 
 	BUG_ON(dst_size > SHA512_DIGEST_SIZE);
-	if (IS_ERR(tfm))
+	if (IS_ERR(tfm)) {
+		printk(KERN_ERR "%s: crypto_alloc_ahash() returned [%ld]\n",
+		       __func__, PTR_ERR(tfm));
 		return PTR_ERR(tfm);
+	}
 	req = ahash_request_alloc(tfm, GFP_NOFS);
 	if (!req) {
 		res = -ENOMEM;
@@ -755,8 +765,11 @@ static int ext4_hmac(bool derivation, const char *key, size_t key_size,
 				   ext4_hmac_complete, &ehr);
 
 	res = crypto_ahash_setkey(tfm, key, key_size);
-	if (res)
+	if (res) {
+		printk(KERN_ERR "%s: crypto_ahash_setkey() returned [%d]\n",
+		       __func__, res);
 		goto out;
+	}
 	sg_init_one(&sg, src, src_size);
 	ahash_request_set_crypt(req, &sg, hmac, src_size);
 	init_completion(&ehr.completion);
@@ -766,13 +779,18 @@ static int ext4_hmac(bool derivation, const char *key, size_t key_size,
 		wait_for_completion(&ehr.completion);
 		res = ehr.res;
 	}
-	if (res)
+	if (res) {
+		printk(KERN_ERR "%s: crypto_ahash_digest() returned [%d]\n",
+		       __func__, res);
 		goto out;
+	}
 	memcpy(dst, hmac, dst_size);
 out:
 	crypto_free_ahash(tfm);
 	if (req)
 		ahash_request_free(req);
+	if (res)
+		printk(KERN_ERR "%s: returning [%d]\n", __func__, res);
 	return res;
 }
 
@@ -836,8 +854,11 @@ static int ext4_crypt_wrapper_virt(const char *enc_key, const char *iv,
 	int res = 0;
 
 	desc.tfm = crypto_alloc_blkcipher("ctr(aes)", 0, CRYPTO_ALG_ASYNC);
-	if (IS_ERR(desc.tfm))
+	if (IS_ERR(desc.tfm)) {
+		printk(KERN_ERR "%s: crypto_alloc_blkcipher() returned [%ld]\n",
+		       __func__, PTR_ERR(desc.tfm));
 		return PTR_ERR(desc.tfm);
+	}
 	if (!desc.tfm)
 		return -ENOMEM;
 	crypto_blkcipher_set_flags(desc.tfm, CRYPTO_TFM_REQ_WEAK_KEY);
@@ -846,12 +867,21 @@ static int ext4_crypt_wrapper_virt(const char *enc_key, const char *iv,
 	crypto_blkcipher_set_iv(desc.tfm, iv, EXT4_WRAPPING_IV_SIZE);
 	res = crypto_blkcipher_setkey(desc.tfm, enc_key,
 				      EXT4_AES_256_CTR_KEY_SIZE);
-	if (res)
+	if (res) {
+		printk(KERN_ERR
+		       "%s: crypto_blkcipher_setkey() returned [%d]\n",
+		       __func__, res);
 		goto out;
+	}
 	if (enc)
 		res = crypto_blkcipher_encrypt(&desc, &dst, &src, size);
 	else
 		res = crypto_blkcipher_decrypt(&desc, &dst, &src, size);
+	if (res) {
+		printk(KERN_ERR
+		       "%s: crypto_blkcipher_*crypt() returned [%d]\n",
+		       __func__, res);
+	}
 out:
 	crypto_free_blkcipher(desc.tfm);
 	return res;
@@ -988,8 +1018,12 @@ static int ext4_wrap_key(char *wrapped_key_packet, size_t *key_packet_size,
 		return 0;
 	}
 	res = ext4_get_wrapping_key(wrapping_key, packet->sig, inode);
-	if (res)
+	if (res) {
+		ext4_error(inode->i_sb,
+			   "%s: ext4_get_wrapping_key() with packet->sig [%s] returned [%d]\n",
+			   __func__, packet->sig, res);
 		return res;
+	}
 	BUG_ON(*key_packet_size != EXT4_FULL_WRAPPED_KEY_PACKET_V0_SIZE);
 
 	/* Size, type, nonce, and IV */
@@ -1005,8 +1039,12 @@ static int ext4_wrap_key(char *wrapped_key_packet, size_t *key_packet_size,
 				   packet->nonce,
 				   EXT4_DERIVATION_TWEAK_NONCE_SIZE,
 				   enc_key, EXT4_AES_256_CTR_KEY_SIZE);
-	if (res)
+	if (res) {
+		ext4_error(inode->i_sb,
+			   "%s: ext4_hmac_derive_key() returned [%d]\n",
+			   __func__, res);
 		goto out;
+	}
 
 	/* Wrap the data key with the wrapping encryption key */
 	*((uint32_t *)key_packet.mode) = htonl(key->mode);
@@ -1019,8 +1057,12 @@ static int ext4_wrap_key(char *wrapped_key_packet, size_t *key_packet_size,
 				      EXT4_V0_SERIALIZED_KEY_SIZE, true);
 	memset(enc_key, 0, EXT4_AES_256_CTR_KEY_SIZE);
 	memset(key_packet.raw, 0, EXT4_MAX_KEY_SIZE);
-	if (res)
+	if (res) {
+		ext4_error(inode->i_sb,
+			   "%s: ext4_crypt_wrapper_virt() returned [%d]\n",
+			   __func__, res);
 		goto out;
+	}
 
 	/* Calculate the HMAC over the entire packet (except, of
 	 * course, the HMAC buffer at the end) */
@@ -1029,8 +1071,12 @@ static int ext4_wrap_key(char *wrapped_key_packet, size_t *key_packet_size,
 				   packet->nonce,
 				   EXT4_DERIVATION_TWEAK_NONCE_SIZE,
 				   int_key, EXT4_HMAC_KEY_SIZE);
-	if (res)
+	if (res) {
+		ext4_error(inode->i_sb,
+			   "%s: ext4_hmac_derive_key() returned [%d]\n",
+			   __func__, res);
 		goto out;
+	}
 	BUILD_BUG_ON(EXT4_FULL_WRAPPED_KEY_PACKET_V0_SIZE < EXT4_HMAC_SIZE);
 	res = ext4_hmac_integrity(int_key, EXT4_HMAC_KEY_SIZE,
 				  wrapped_key_packet,
@@ -1041,6 +1087,8 @@ static int ext4_wrap_key(char *wrapped_key_packet, size_t *key_packet_size,
 	memset(int_key, 0, EXT4_HMAC_KEY_SIZE);
 out:
 	memset(wrapping_key, 0, EXT4_AES_256_XTS_KEY_SIZE);
+	if (res)
+		ext4_error(inode->i_sb, "%s: returning [%d]\n", __func__, res);
 	return res;
 }
 
@@ -1084,8 +1132,12 @@ try_again:
 	ext4_generate_encryption_key(dentry);
 	res = ext4_wrap_key(wrapped_key_packet, &wrapped_key_packet_size,
 			    &ei->i_encryption_key, inode);
-	if (res)
+	if (res) {
+		ext4_error(dentry->d_inode->i_sb,
+			   "%s: ext4_wrap_key() returned [%d]\n", __func__,
+			   res);
 		goto out;
+	}
 	root_packet[0] = EXT4_PACKET_SET_VERSION_V0;
 	BUILD_BUG_ON(EXT4_PACKET_SET_V0_MAX_SIZE !=
 		     (EXT4_PACKET_HEADER_SIZE +
@@ -1093,6 +1145,11 @@ try_again:
 	BUG_ON(sizeof(root_packet) != root_packet_size);
 	res = ext4_xattr_set(inode, EXT4_XATTR_INDEX_ENCRYPTION_METADATA, "",
 			     root_packet, root_packet_size, 0);
+	if (res) {
+		ext4_error(dentry->d_inode->i_sb,
+			   "%s: ext4_xattr_set() returned [%d]\n", __func__,
+			   res);
+	}
 out:
 	if (res) {
 		if (res == -EINTR)
-- 
2.1.0.rc2.206.gedb03e5

