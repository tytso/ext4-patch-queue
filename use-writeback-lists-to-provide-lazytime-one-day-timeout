vfs: use writeback lists to provide lazytime one day timeout

Queue inodes with dirty timestamps for writeback 24 hours after they
were initially dirtied.

Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 fs/fs-writeback.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index 518f3bb..bf8b928 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -253,7 +253,7 @@ static bool inode_dirtied_after(struct inode *inode, unsigned long t)
  */
 static int move_expired_inodes(struct list_head *delaying_queue,
 			       struct list_head *dispatch_queue,
-			       struct wb_writeback_work *work)
+			       unsigned long *older_than_this)
 {
 	LIST_HEAD(tmp);
 	struct list_head *pos, *node;
@@ -264,8 +264,8 @@ static int move_expired_inodes(struct list_head *delaying_queue,
 
 	while (!list_empty(delaying_queue)) {
 		inode = wb_inode(delaying_queue->prev);
-		if (work->older_than_this &&
-		    inode_dirtied_after(inode, *work->older_than_this))
+		if (older_than_this &&
+		    inode_dirtied_after(inode, *older_than_this))
 			break;
 		list_move(&inode->i_wb_list, &tmp);
 		moved++;
@@ -309,9 +309,14 @@ out:
 static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)
 {
 	int moved;
+	unsigned long one_day_later = jiffies + (HZ * 86400);
+
 	assert_spin_locked(&wb->list_lock);
 	list_splice_init(&wb->b_more_io, &wb->b_io);
-	moved = move_expired_inodes(&wb->b_dirty, &wb->b_io, work);
+	moved = move_expired_inodes(&wb->b_dirty, &wb->b_io,
+				    work->older_than_this);
+	moved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,
+				     &one_day_later);
 	trace_writeback_queue_io(wb, work, moved);
 }
 
@@ -1241,9 +1246,10 @@ void inode_requeue_dirtytime(struct inode *inode)
 	spin_lock(&bdi->wb.list_lock);
 	spin_lock(&inode->i_lock);
 	if ((inode->i_state & I_DIRTY_WB) == 0) {
-		if (inode->i_state & I_DIRTY_TIME)
+		if (inode->i_state & I_DIRTY_TIME) {
+			inode->dirtied_when = jiffies;
 			list_move(&inode->i_wb_list, &bdi->wb.b_dirty_time);
-		else
+		} else
 			list_del_init(&inode->i_wb_list);
 	}
 	spin_unlock(&inode->i_lock);
