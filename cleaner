Introduce cleaner

From: Abutalib Aghayev <agayev@cs.cmu.edu>

An experimental cleaner.  Copy the live blocks from the transaction at the
tail in batches to the transaction at the head.  After a commit ends, check
if free space is below watermark and start cleaning until free space is
above high watermark.

Signed-off-by: Abutalib Aghayev <agayev@cs.cmu.edu>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 fs/jbd2/Makefile     |  2 +-
 fs/jbd2/checkpoint.c |  3 +++
 fs/jbd2/jmap.c       | 34 ++++++++++++++++++++++++++++++++++
 fs/jbd2/jmap.h       | 82 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/jbd2/journal.c    | 12 ++++++++++++
 include/linux/jbd2.h |  6 +++++-
 6 files changed, 137 insertions(+), 2 deletions(-)

diff --git a/fs/jbd2/Makefile b/fs/jbd2/Makefile
index a54f50b3a06e..b6a2dddcc0a7 100644
--- a/fs/jbd2/Makefile
+++ b/fs/jbd2/Makefile
@@ -5,4 +5,4 @@
 obj-$(CONFIG_JBD2) += jbd2.o
 
 jbd2-objs := transaction.o commit.o recovery.o checkpoint.o revoke.o journal.o \
-		jmap.o
+		jmap.o cleaner.o
diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index 4055f51617ef..b60bbf58e8f7 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -389,6 +389,9 @@ int jbd2_cleanup_journal_tail(journal_t *journal)
 	tid_t		first_tid;
 	unsigned long	blocknr;
 
+	if (journal->j_flags & JBD2_LAZY)
+		return 0;
+
 	if (is_journal_aborted(journal))
 		return -EIO;
 
diff --git a/fs/jbd2/jmap.c b/fs/jbd2/jmap.c
index 7de6f4a0a1dc..24db169b6f2d 100644
--- a/fs/jbd2/jmap.c
+++ b/fs/jbd2/jmap.c
@@ -91,8 +91,17 @@ static int process_existing_mappings(journal_t *journal,
 		 * We are either deleting the entry because it was revoked, or
 		 * we are moving it to the live blocks list of this transaction.
 		 * In either case, we remove it from its existing list.
+		 * However, before removing it we check to see if this is an
+		 * entry in the live blocks list of the tail transaction a
+		 * pointer to whom is cached by the cleaner and update the
+		 * cached pointer if so.
 		 */
+		spin_lock(&journal->j_cleaner_ctx->pos_lock);
+		if (je == journal->j_cleaner_ctx->pos) {
+			journal->j_cleaner_ctx->pos = list_next_entry(je, list);
+		}
 		list_del(&je->list);
+		spin_unlock(&journal->j_cleaner_ctx->pos_lock);
 
 		if (je->revoked) {
 			rb_erase(&je->rb_node, &journal->j_jmap);
@@ -216,6 +225,8 @@ void jbd2_finish_transaction_infos(journal_t *journal)
 {
 	struct transaction_infos *tis = journal->j_transaction_infos;
 
+	atomic_inc(&journal->j_cleaner_ctx->nr_txns_committed);
+
 	write_lock(&journal->j_jmap_lock);
 	tis->head = (tis->head + 1) & (MAX_LIVE_TRANSACTIONS - 1);
 	write_unlock(&journal->j_jmap_lock);
@@ -243,6 +254,8 @@ int jbd2_transaction_infos_add(journal_t *journal, transaction_t *transaction,
 	 */
 	BUG_ON(!list_empty(&ti->live_blks));
 
+	atomic_inc(&journal->j_cleaner_ctx->nr_txns_committed);
+
 	write_lock(&journal->j_jmap_lock);
 	nr_new = process_existing_mappings(journal, ti, t_idx, mappings,
 					nr_mappings);
@@ -489,11 +502,32 @@ int jbd2_smr_journal_init(journal_t *journal)
 {
 	journal->j_jmap = RB_ROOT;
 	rwlock_init(&journal->j_jmap_lock);
+	journal->j_cleaner_ctx = kzalloc(sizeof(struct cleaner_ctx),
+					 GFP_KERNEL);
+	if (!journal->j_cleaner_ctx)
+		return -ENOMEM;
+
+	journal->j_cleaner_ctx->journal = journal;
+	journal->j_cleaner_ctx->pos = NULL;
+	spin_lock_init(&journal->j_cleaner_ctx->pos_lock);
+	atomic_set(&journal->j_cleaner_ctx->cleaning, 0);
+	atomic_set(&journal->j_cleaner_ctx->batch_in_progress, 0);
+	atomic_set(&journal->j_cleaner_ctx->nr_pending_reads, 0);
+	atomic_set(&journal->j_cleaner_ctx->nr_txns_committed, 0);
+	atomic_set(&journal->j_cleaner_ctx->nr_txns_cleaned, 0);
+	init_completion(&journal->j_cleaner_ctx->live_block_reads);
+	INIT_WORK(&journal->j_cleaner_ctx->work, jbd2_jmap_do_clean_batch);
 	return jbd2_init_transaction_infos(journal);
 }
 
 void jbd2_smr_journal_exit(journal_t *journal)
 {
+	if (journal->j_cleaner_ctx) {
+		atomic_set(&journal->j_cleaner_ctx->cleaning, 0);
+		flush_work(&journal->j_cleaner_ctx->work);
+		kfree(journal->j_cleaner_ctx);
+		journal->j_cleaner_ctx = NULL;
+	}
 	jbd2_free_transaction_infos(journal);
 }
 
diff --git a/fs/jbd2/jmap.h b/fs/jbd2/jmap.h
index 91564ce9bbda..4f50e43723cc 100644
--- a/fs/jbd2/jmap.h
+++ b/fs/jbd2/jmap.h
@@ -125,4 +125,86 @@ extern void jbd2_jmap_cancel_revoke(journal_t *journal, sector_t fsblk);
 extern int read_block_from_log(journal_t *journal, struct buffer_head *bh,
 			       int op_flags, sector_t blk);
 
+extern void jbd2_jmap_do_clean_batch(struct work_struct *work);
+
+/*
+ * Cleaner stuff is below.
+ */
+
+/*
+ * Number of blocks to read at once, for cleaning.
+ */
+#define CLEANER_BATCH_SIZE 16
+
+/*
+ * Context structure for the cleaner.
+ */
+struct cleaner_ctx {
+	/*
+	 * We set to true once we drop below low watermark and it stays so until
+	 * we rise above the high watermark.  It is accessed by the commit
+	 * thread and the foreground kernel threads during the journal
+	 * destruction, therefore it is atomic.
+	 */
+	atomic_t cleaning;
+
+	/*
+	 * We clean in batches of blocks.  This flag indicates if we are
+	 * currently cleaning a batch.  It is accessed by the commit thread and
+	 * the cleaner thread, therefore it is atomic.
+	 */
+	atomic_t batch_in_progress;
+
+	/*
+	 * We find live blocks to clean from the live blocks list of the
+	 * transaction at the tail.  This list can be larger than our batch size
+	 * and we may need several attempts to process it.  We cache the
+	 * position of the next entry to start from in |pos|.  Since cleaner
+	 * thread can run concurrently with the commit thread that can modify
+	 * the live blocks list of the transaction at the tail (for example, if
+	 * it needs to drop a revoked entry or if |pos| points to an entry that
+	 * has been updated and should move from the live blocks list of the
+	 * transaction at the tail to the live blocks list of current
+	 * transaction) we protect |pos| with |pos_lock|.
+	 */
+	struct jmap_entry *pos;
+	spinlock_t pos_lock;
+
+	/*
+	 * Live block mappings for the blocks that we copy in a batch.
+	 */
+	struct blk_mapping mappings[CLEANER_BATCH_SIZE];
+
+	/*
+	 * Buffer heads for the live blocks read in a batch.
+	 */
+	struct buffer_head *bhs[CLEANER_BATCH_SIZE];
+
+	/*
+	 * Number of pending reads in a batch.  Every submitted read increments
+	 * it and every completed read decrements it.
+	 */
+	atomic_t nr_pending_reads;
+
+	/*
+	 * The cleaner thread sleeps on this condition variable until the last
+	 * completed read wakes the up the cleaner thread.
+	 */
+	struct completion live_block_reads;
+
+	/* TODO: temporary for debugging, remove once done. */
+	atomic_t nr_txns_committed;
+	atomic_t nr_txns_cleaned;
+
+	journal_t *journal;
+	struct work_struct work;
+};
+
+extern int jbd2_low_on_space(journal_t *journal);
+extern int jbd2_high_on_space(journal_t *journal);
+extern bool jbd2_cleaning(journal_t *journal);
+extern void jbd2_stop_cleaning(journal_t *journal);
+extern void jbd2_start_cleaning(journal_t *journal);
+extern bool jbd2_cleaning_batch_complete(journal_t *journal);
+extern bool jbd2_try_to_move_tail(journal_t *journal);
 #endif
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 50ab9b5bc7f4..9c097ddfe63f 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -229,6 +229,15 @@ static int kjournald2(void *arg)
 	}
 
 	wake_up(&journal->j_wait_done_commit);
+
+	if ((journal->j_flags & JBD2_LAZY) &&
+	    (jbd2_cleaning(journal) || jbd2_low_on_space(journal))) {
+		if (jbd2_try_to_move_tail(journal) && jbd2_high_on_space(journal))
+			jbd2_stop_cleaning(journal);
+		else
+			jbd2_start_cleaning(journal);
+	}
+
 	if (freezing(current)) {
 		/*
 		 * The simpler the better. Flushing journal isn't a
@@ -257,6 +266,9 @@ static int kjournald2(void *arg)
 			should_sleep = 0;
 		if (journal->j_flags & JBD2_UNMOUNT)
 			should_sleep = 0;
+		if ((journal->j_flags & JBD2_LAZY) &&
+		    jbd2_cleaning_batch_complete(journal))
+			should_sleep = 0;
 		if (should_sleep) {
 			write_unlock(&journal->j_state_lock);
 			schedule();
diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h
index a1d56bb9fa4f..fa6094124bcb 100644
--- a/include/linux/jbd2.h
+++ b/include/linux/jbd2.h
@@ -734,7 +734,8 @@ jbd2_time_diff(unsigned long start, unsigned long end)
  * @j_superblock: Second part of superblock buffer
  * @j_map: A map from file system blocks to log blocks
  * @j_transaction_infos: An array of information structures per live transaction
- * @j_map_lock: Protect j_jmap and j_transaction_infos
+ * @j_jmap_lock: Protect j_jmap and j_transaction_infos
+ * @j_cleaner_ctx: Cleaner state
  * @j_format_version: Version of the superblock format
  * @j_state_lock: Protect the various scalars in the journal
  * @j_barrier_count:  Number of processes waiting to create a barrier lock
@@ -819,6 +820,9 @@ struct journal_s
 	/* Protect j_jmap and j_transaction_infos */
 	rwlock_t		j_jmap_lock;
 
+	/* Cleaner state */
+	struct cleaner_ctx	*j_cleaner_ctx;
+
 	/* Version of the superblock format */
 	int			j_format_version;
 
