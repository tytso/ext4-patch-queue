ext4: factor out __es_get_tree()

Factor out a routine which searches the extent status tree and returns
an element from it if and only if it exists.  This is different from
__es_search_tree() which returns the next extent in the tree if an
extent covering the logical block number does not exist.

Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
Cc: Zheng Liu <wenqing.lz@taobao.com>
diff --git a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c
index 7358fb3..ba22eec1 100644
--- a/fs/ext4/extents_status.c
+++ b/fs/ext4/extents_status.c
@@ -232,6 +232,24 @@ static struct extent_status *__es_tree_search(struct rb_root *root,
 	return NULL;
 }
 
+static struct extent_status *__es_tree_get(struct rb_root *root,
+					   ext4_lblk_t lblk)
+{
+	struct rb_node *node = root->rb_node;
+	struct extent_status *es;
+
+	while (node) {
+		es = rb_entry(node, struct extent_status, rb_node);
+		if (lblk < es->es_lblk)
+			node = node->rb_left;
+		else if (lblk > ext4_es_end(es))
+			node = node->rb_right;
+		else
+			return es;
+	}
+	return NULL;
+}
+
 /*
  * ext4_es_find_delayed_extent_range: find the 1st delayed extent covering
  * @es->lblk if it exists, otherwise, the next extent after @es->lblk.
@@ -701,34 +719,21 @@ int ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,
 	/* find extent in cache firstly */
 	es->es_lblk = es->es_len = es->es_pblk = 0;
 	if (tree->cache_es) {
-		es1 = tree->cache_es;
-		if (in_range(lblk, es1->es_lblk, es1->es_len)) {
+		struct extent_status *c_es = tree->cache_es;
+		if (in_range(lblk, c_es->es_lblk, c_es->es_len)) {
+			es1 = c_es;
 			es_debug("%u cached by [%u/%u)\n",
 				 lblk, es1->es_lblk, es1->es_len);
-			found = 1;
 			goto out;
 		}
 	}
-
-	node = tree->root.rb_node;
-	while (node) {
-		es1 = rb_entry(node, struct extent_status, rb_node);
-		if (lblk < es1->es_lblk)
-			node = node->rb_left;
-		else if (lblk > ext4_es_end(es1))
-			node = node->rb_right;
-		else {
-			found = 1;
-			break;
-		}
-	}
-
+	es1 = __es_tree_get(&tree->root, lblk);
 out:
-	if (found) {
-		BUG_ON(!es1);
+	if (es1) {
 		es->es_lblk = es1->es_lblk;
 		es->es_len = es1->es_len;
 		es->es_pblk = es1->es_pblk;
+		found = 1;
 	}
 
 	read_unlock(&EXT4_I(inode)->i_es_lock);
