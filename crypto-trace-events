ext4 crypto: trace events for encrypt and decrypt

From: Michael Halcrow <mhalcrow@google.com>

Signed-off-by: Michael Halcrow <mhalcrow@google.com>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 fs/ext4/crypto.c            | 34 ++++++++++++++++++++++++++++++++-
 include/trace/events/ext4.h | 46 +++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 79 insertions(+), 1 deletion(-)

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index e16170f..30cfaa9 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -31,6 +31,8 @@
 #include "ext4.h"
 #include "xattr.h"
 
+#include <trace/events/ext4.h>
+
 /* Encryption added and removed here! (L: */
 
 mempool_t *ext4_bounce_page_pool = NULL;
@@ -447,6 +449,13 @@ struct page *ext4_encrypt(struct ext4_crypto_ctx *ctx,
 			  struct page *plaintext_page)
 {
 	struct page *ciphertext_page = NULL;
+	char c0, c4095, p0, p4095;
+	char *page_virt;
+
+	page_virt = kmap(plaintext_page);
+	p0 = page_virt[0];
+	p4095 = page_virt[PAGE_CACHE_SIZE - 1];
+	kunmap(plaintext_page);
 
 	BUG_ON(!PageLocked(plaintext_page));
 	switch (ctx->mode) {
@@ -464,8 +473,16 @@ struct page *ext4_encrypt(struct ext4_crypto_ctx *ctx,
 	default:
 		BUG();
 	}
-	if (!IS_ERR_OR_NULL(ciphertext_page))
+	if (!IS_ERR_OR_NULL(ciphertext_page)) {
 		ext4_prep_pages_for_write(ciphertext_page, plaintext_page, ctx);
+
+		page_virt = kmap(ciphertext_page);
+		c0 = page_virt[0];
+		c4095 = page_virt[PAGE_CACHE_SIZE - 1];
+		kunmap(ciphertext_page);
+
+		trace_ext4_encrypt(plaintext_page, p0, p4095, c0, c4095);
+	}
 	return ciphertext_page;
 }
 
@@ -549,6 +566,13 @@ bool __ext4_debug_is_page_zero(struct page *page)
 int ext4_decrypt(struct ext4_crypto_ctx *ctx, struct page *page)
 {
 	int res = 0;
+	char c0, c4095, p0, p4095;
+	char *page_virt;
+
+	page_virt = kmap(page);
+	c0 = page_virt[0];
+	c4095 = page_virt[PAGE_CACHE_SIZE - 1];
+	kunmap(page);
 
 	BUG_ON(!PageLocked(page));
 	BUG_ON(__ext4_debug_is_page_zero(page));
@@ -564,6 +588,14 @@ int ext4_decrypt(struct ext4_crypto_ctx *ctx, struct page *page)
 	default:
 		BUG();
 	}
+
+	page_virt = kmap(page);
+	p0 = page_virt[0];
+	p4095 = page_virt[PAGE_CACHE_SIZE - 1];
+	kunmap(page);
+
+	trace_ext4_decrypt(page, p0, p4095, c0, c4095);
+
 	return res;
 }
 
diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index d4f70a7..91835b1 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -494,6 +494,38 @@ DECLARE_EVENT_CLASS(ext4__page_op,
 		  (unsigned long) __entry->index)
 );
 
+DECLARE_EVENT_CLASS(ext4__page_crypt_op,
+	TP_PROTO(struct page *page, char p0, char p4095, char c0, char c4095),
+
+	TP_ARGS(page, p0, p4095, c0, c4095),
+
+	TP_STRUCT__entry(
+		__field(	ino_t,	ino			)
+		__field(	pgoff_t, index			)
+		__field(	char,	p0			)
+		__field(	char,	p4095			)
+		__field(	char,	c0			)
+		__field(	char,	c4095			)
+	),
+
+	TP_fast_assign(
+		__entry->ino	= page->mapping->host->i_ino;
+		__entry->index	= page->index;
+		__entry->p0	= p0;
+		__entry->p4095	= p4095;
+		__entry->c0	= c0;
+		__entry->c4095	= c4095;
+	),
+
+	TP_printk("ino %lu page_index %lu p0 %.2x p4095 %.2x c0 %.2x c4095 %.2x",
+		  (unsigned long) __entry->ino,
+		  (unsigned long) __entry->index,
+		  (unsigned char) __entry->p0,
+		  (unsigned char) __entry->p4095,
+		  (unsigned char) __entry->c0,
+		  (unsigned char) __entry->c4095)
+);
+
 DEFINE_EVENT(ext4__page_op, ext4_writepage,
 
 	TP_PROTO(struct page *page),
@@ -515,6 +547,20 @@ DEFINE_EVENT(ext4__page_op, ext4_releasepage,
 	TP_ARGS(page)
 );
 
+DEFINE_EVENT(ext4__page_crypt_op, ext4_encrypt,
+
+	TP_PROTO(struct page *page, char p0, char p4095, char c0, char c4095),
+
+	TP_ARGS(page, p0, p4095, c0, c4095)
+);
+
+DEFINE_EVENT(ext4__page_crypt_op, ext4_decrypt,
+
+	TP_PROTO(struct page *page, char p0, char p4095, char c0, char c4095),
+
+	TP_ARGS(page, p0, p4095, c0, c4095)
+);
+
 DECLARE_EVENT_CLASS(ext4_invalidatepage_op,
 	TP_PROTO(struct page *page, unsigned int offset, unsigned int length),
 
-- 
2.1.0.rc2.206.gedb03e5


