ext4: fix seek_data for indirect layout

From: Dmitri Monakho <dmonakhov@openvz.org>

We obtain block mapping info via fiemap, in case of indirect inodes
it handled via generic_block_fiemap(). That function does not care
about delayed allocation. So we have to lookup delayed blocks explicitly.

*XFSTEST*
MKFS_OPTIONS:   -- -q -O ^extents,^flex_bg,^uninit_bg /dev/vdc
MOUNT_OPTIONS: -- -o acl,user_xattr -o block_validity,nodelalloc /dev/vdc /vdc
TEST: generic/285

tested on following configurations: 4k, 1k, ext3, ext3-1k, ext3-1k-da

Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
Signed-off-by: Theodore Ts'o <tytso@mit.edu>
---
 fs/ext4/file.c |   26 ++++++++++++++++++++++++--
 1 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 8ec48a4..b0dc982 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -407,14 +407,26 @@ static loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)
 	struct inode *inode = file->f_mapping->host;
 	struct fiemap_extent_info fie;
 	struct fiemap_extent ext[2];
-	loff_t next;
+	loff_t next, delayed = offset;
 	int i, ret = 0;
+	bool has_delay = false;
 
 	mutex_lock(&inode->i_mutex);
 	if (offset >= inode->i_size) {
 		mutex_unlock(&inode->i_mutex);
 		return -ENXIO;
 	}
+	/* Explicitly search for delayed blocks for indirect layout because
+	 * generic_block_fiemap() can not do it for us. */
+	if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&
+	    test_opt(inode->i_sb, DELALLOC) &&
+	    ext4_find_delayed_pgoff(inode, SEEK_DATA, maxsize, &delayed)) {
+		if (delayed  == offset)
+			goto out;
+		maxsize = delayed;
+		has_delay = true;
+	}
+
 	fie.fi_flags = 0;
 	fie.fi_extents_max = 2;
 	fie.fi_extents_start = (struct fiemap_extent __user *) &ext;
@@ -432,7 +444,10 @@ static loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)
 
 		/* No extents found, EOF */
 		if (!fie.fi_extents_mapped) {
-			ret = -ENXIO;
+			if (has_delay)
+				offset = delayed;
+			else
+				ret = -ENXIO;
 			break;
 		}
 		for (i = 0; i < fie.fi_extents_mapped; i++) {
@@ -496,6 +511,13 @@ static loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)
 	while (1) {
 		mm_segment_t old_fs = get_fs();
 
+		/* Explicitly search for delayed blocks for indirect layout
+		   because generic_block_fiemap() can not do it for us. */
+		if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &&
+		    test_opt(inode->i_sb, DELALLOC))
+			ext4_find_delayed_pgoff(inode, SEEK_HOLE, maxsize,
+						&offset);
+
 		fie.fi_extents_mapped = 0;
 		memset(ext, 0, sizeof(*ext));
 
